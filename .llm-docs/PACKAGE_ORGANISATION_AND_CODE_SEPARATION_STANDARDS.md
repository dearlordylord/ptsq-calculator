# Vibe Coding Frontier

A high-level specification for organizing and marking code that is generated or heavily assisted by LLMs (“vibe code”) versus human-vetted modules. This document is language-agnostic but uses TypeScript examples.

---

## 1. Module & Interface Anatomy

### 1.1 Separation of Concerns

- **`moduleX-interface`**: Written and reviewed by humans. Defines all contracts, types, invariants, codecs, and validation utilities that clients (including vibe code) must adhere to.
- **`moduleX`**: Can be fully generated by LLMs. Implements the functionality and must conform to the corresponding interface.

### 1.2 Interface Contents

Each `*-interface` file SHOULD include:

1. **Type Definitions**: Core data shapes (e.g., union types, generics, tagged/nominal types).
2. **Invariant Descriptions**: Comments or JSDoc explaining constraints that the type system cannot enforce (e.g., `a === 2 * b`).
3. **Validation Utilities**: Functions or schemas (Zod, io-ts, custom) to enforce invariants at runtime before data enters vibe code.
4. **Runtime Codecs** (optional): Serialization/deserialization logic if the module boundary crosses process or network boundaries.
5. **Test Stubs**: Placeholder signatures or minimal human-written tests for core invariants.

#### Inline Example: `account-interface.ts`

```ts
// account-interface.ts

/**
 * Account identifier.
 */
export type AccountID = string; // but ideally, validated nominal type
export type Balance = number; // but ideally, validated nominal type

/**
 * Account balance: must be >= 0.
 */
export type Account = {
  id: AccountID;
  balance: Balance;
};

/**
 * Invariant: `balance >= 0`.
 */
// but ideally, not a function but a proper codec lib (like effect/schema)
export function validateAccount(a: Account): asserts a is Account {
  if (a.balance < 0) {
    throw new Error(`Invariant violation: balance < 0 (got ${a.balance})`);
  }
}
```

### 1.3 Conformance

- Vibe code (`moduleX`) MUST import and use the interface definitions and validation utilities before any core logic.
- If the LLM implementation omits or misuses an invariant, tests will catch the discrepancy.

---

## 2. Frontier Requirements

### 2.1 Types

- Use explicit union and generic types at the interface boundary.
- Prefer tagged unions for clear success/failure branches:

  ```ts
  export type Result<T> = // but ideally, a Result-like type, like Either, from one of libraries (e.g. Effect)
    { type: "ok"; result: T } | { type: "fail"; error: string };
  ```

### 2.2 Invariants

- **Definition**: Constraints beyond what the compiler/type-checker can guarantee (e.g., sorted arrays, relational properties).
- **NASA-Style Reassertions**: Vibe code MAY re-run key invariant validations, and encouraged to do so extensively

### 2.3 Runtime Rules

- Define non-functional requirements (e.g., rate-limits, idempotency, ordering), if any, in interface comments.
- Provide helper functions or types to encapsulate these rules.

---

## 3. Marking & Locating Vibe Code

- **Package-Level**: In `README.md` of each module, tell explicitly if the module is vibe coded (mark as "# @vibe-generated")
- **File-Level**: At the top of a vibe-generated file, add: (only if not already marked at root level in README)

  ```ts
  // @vibe-generated: conforms to moduleX-interface
  ```

- **Inline Regions**: Surround LLM-generated regions with tags: (only if not already marked at file or root level in README)

  ```ts
  /*<vibe-generated>*/
  // LLM-generated block
  /*</vibe-generated>*/
  ```

---

## 4. Testing Strategy

### 4.1 Human-Written Tests

- Cover core invariants, edge cases, and integration with downstream modules.
- Stored alongside interface files (e.g., `account-interface.spec.ts`).

### 4.2 Vibe-Generated Tests

- Generated by LLM to cover happy-path and common scenarios.
- Named `moduleX.vibe.spec.ts` or placed in a `*.vibe.spec.ts` file next to the implementation.

---

## 5. Example Module Skeleton

### 5.1 `foo-interface.ts`

```ts
// foo-interface.ts

type NonNegativeInteger = number; // but ideally, a properly parsed nominal type that is never floaty or never negative
export type FooInput = { x: NonNegativeInteger; y: NonNegativeInteger };
export type FooOutput = NonNegativeInteger;

/**
 * Invariant: `x == y*2`
 * but ideally, codecs
 */
export function validateFooInput(i: {
  x: NonNegativeInteger;
  y: NonNegativeInteger;
}): asserts i is FooInput {
  if (i.x !== i.y * 2) {
    throw new Error("invariant error: ...");
  }
}

// but ideally, codecs
export function validateFooOutput(x: number): asserts x is FooOutput; // ...
```

### 5.2 `foo.ts`

```ts
// @vibe-generated: conforms to foo-interface.ts
import { FooInput, FooOutput, validateFooInput } from "./foo-interface";

export function computeFoo(i: FooInput): FooOutput {
  const sum = i.x + i.y;

  validateFooOutput(sum);

  return sum;
}
```
